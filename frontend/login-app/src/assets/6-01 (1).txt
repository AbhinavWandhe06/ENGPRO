const { Pool } = require("pg");

// Database configuration
const config = {
  user: "postgres", // Database username
  host: "localhost", // Database host
  database: "licensesolution", // Database name
  password: "Pass@123", // Database password
  port: 5433, // Database port (make sure this is correct)
};

// Initialize the Pool for better performance
const pool = new Pool(config);

// Test the connection
pool
  .connect()
  .then((client) => {
    console.log("Database connected successfully");
    client.release();
  })
  .catch((err) => console.error("Error connecting to the database:", err));

// Function to insert a new user without a password
const insertUserWithoutPassword = async (userId, username) => {
  try {
    const role = "end-user"; // Default role
    console.log(
      `Inserting user with ID: ${userId}, Username: ${username}, Role: ${role}`
    );
    const query = `INSERT INTO users (user_id, username, role) VALUES ($1, $2, $3)`;
    await pool.query(query, [userId, username, role]);
    console.log("User inserted:", userId, username, role);
  } catch (error) {
    console.error("Error inserting user:", error.message);
    throw error;
  }
};

// Function to insert a new feature
const insertFeature = async (featureId, featureName, vendorId) => {
  try {
    // Check if the feature already exists to prevent duplicates
    const existingFeature = await pool.query(
      "SELECT * FROM feature WHERE feature_id = $1",
      [featureId]
    );
    if (existingFeature.rows.length > 0) {
      throw new Error("Feature with this ID already exists.");
    }

    // Insert the new feature
    const insertQuery = `INSERT INTO feature (feature_id, feature_name, v_id) VALUES ($1, $2, $3)`;
    await pool.query(insertQuery, [featureId, featureName, vendorId]);
    console.log("Feature inserted:", featureId, featureName, vendorId);
  } catch (error) {
    console.error("Error inserting feature:", error.message);
    throw error; // Rethrow the error so the calling function can handle it
  }
};

// Function to delete a feature
const deleteFeature = async (featureId) => {
  try {
    // Get `f_id` from `feature_id`
    const feature = await pool.query(
      `SELECT f_id FROM feature WHERE feature_id = $1`,
      [featureId]
    );
    if (feature.rows.length === 0) {
      throw new Error("Feature not found.");
    }
    const f_id = feature.rows[0].f_id;
    // Check if `f_id` is linked in `feature_product_map`
    const linkedProduct = await pool.query(
      `SELECT * FROM feature_product_map WHERE f_id = $1`,
      [f_id]
    );
    console.log("Linked Product:", linkedProduct.rows); // Debug log

    if (linkedProduct.rows.length > 0) {
      throw new Error("Feature is linked to a product and cannot be deleted.");
    }

    // Proceed with deletion if no linked products

    const deleteQuery = `DELETE FROM feature WHERE f_id = $1`;

    await pool.query(deleteQuery, [f_id]);

    console.log("Feature deleted:", f_id);
  } catch (error) {
    console.error("Error deleting feature:", error.message);

    throw error;
  }
};

// Function to get all feature details from the database
const getAllFeatureDetailsFromDb = async () => {
  try {
    const featureRes = await pool.query(
      "SELECT f_id, feature_id, feature_name, v_id FROM feature"
    );
    return featureRes.rows.map((feature) => ({
      f_id: feature.f_id,
      featureId: feature.feature_id,
      featureName: feature.feature_name,
      vendorId: feature.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving features:", error.message);
    throw error;
  }
};

// Function to get features by vendor
const getFeaturesByVendor = async (vendorId) => {
  try {
    const query =
      "SELECT f_id, feature_id, feature_name FROM feature WHERE v_id = $1";
    const res = await pool.query(query, [vendorId]);
    return res.rows.map((feature) => ({
      f_id: feature.f_id,
      featureId: feature.feature_id,
      featureName: feature.feature_name,
    }));
  } catch (error) {
    console.error("Error retrieving vendor features:", error.message);
    throw error;
  }
};

// Function to insert a user (with role validation)
const insertUser = async (userId, username, password, role = "end-user") => {
  try {
    const query = `INSERT INTO users (user_id, username, password, role) VALUES ($1, $2, $3, $4)`;
    await pool.query(query, [userId, username, password, role]);
    console.log("User inserted:", userId, username, role);
  } catch (error) {
    console.error("Error inserting user:", error.message);
    throw error;
  }
};

// Function to insert user into user_batch table
const insertUserBatch = async (userId, batchId) => {
  try {
    const query = `INSERT INTO user_batch_map (user_id, b_id) VALUES ($1, $2)`;
    await pool.query(query, [userId, batchId]);
    console.log("User added to batch:", userId, batchId);
  } catch (error) {
    console.error("Error inserting into user_batch_map:", error.message);
    throw error;
  }
};

const getUserBatch = async (userId) => {
  try {
    const query = `SELECT * FROM user_batch_map WHERE user_id = $1`;
    const res = await pool.query(query, [userId]);
    return res.rows;
  } catch (error) {
    console.error("Error retrieving user batch:", error.message);
    throw error;
  }
};

// Function to get user by user ID
const getUserByUserId = async (userId) => {
  try {
    const query = "SELECT * FROM users WHERE user_id = $1";
    const res = await pool.query(query, [userId]);
    return res.rows[0];
  } catch (error) {
    console.error("Error retrieving user:", error.message);
    throw error;
  }
};

// Function to insert a new product into the "Product" table
// Function to insert a new product
const insertProduct = async (productId, productName, vendorId) => {
  const query = `
    INSERT INTO product (product_id, product_name, v_id)
    VALUES ($1, $2, $3)
    RETURNING *;
  `;
  const values = [productId, productName, vendorId];
  const result = await pool.query(query, values);
  return result.rows[0]; // Returns the newly inserted product, including the p_id
};

const insertMapping = async (featureId, productId, vendorId) => {
  const query = `
    INSERT INTO feature_product_map (f_id, p_id, v_id)
    VALUES ($1, $2, $3);
  `;
  const values = [featureId, productId, vendorId];
  await pool.query(query, values);
};

// Function to delete a product from the "Product" table
const deleteProduct = async (productId) => {
  try {
    // Get `p_id` from `product_id`
    const product = await pool.query(
      `SELECT p_id FROM product WHERE product_id = $1`,
      [productId]
    );
    if (product.rows.length === 0) {
      throw new Error("Product not found.");
    }
    const p_id = product.rows[0].p_id;
    // Check if `p_id` is linked in `product_ent_map`
    const linkedEntitlement = await pool.query(
      `SELECT * FROM product_ent_map WHERE p_id = $1`,
      [p_id]
    );
    console.log("Linked Entitlement:", linkedEntitlement.rows); // Debug log
    if (linkedEntitlement.rows.length > 0) {
      throw new Error(
        "Product is linked to an entitlement and cannot be deleted."
      );
    }
    // Proceed with deletion if not linked to any entitlement
    const deleteQuery = `DELETE FROM product WHERE p_id = $1`;
    await pool.query(deleteQuery, [p_id]);
    console.log("Product deleted:", p_id);
  } catch (error) {
    console.error("Error deleting product:", error.message);
    throw error;
  }
};

// Function to retrieve all products from the "Product" table
const getAllProducts = async () => {
  try {
    const productRes = await pool.query("SELECT * FROM product");
    return productRes.rows.map((product) => ({
      p_id: product.p_id,
      productId: product.product_id,
      productName: product.product_name,
      vendorId: product.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving products:", error.message);
    throw error;
  }
};

// Function to retrieve products by vendor
const getProductsByVendor = async (vendorId) => {
  try {
    const query = "SELECT * FROM product WHERE v_id = $1";
    const res = await pool.query(query, [vendorId]);
    return res.rows.map((product) => ({
      p_id: product.p_id,
      productId: product.product_id,
      productName: product.product_name,
    }));
  } catch (error) {
    console.error("Error retrieving vendor products:", error.message);
    throw error;
  }
};

// Function to insert a new batch with v_id
const insertBatch = async (batchCode, vendorId, batchName = null) => {
  try {
    // Validate the batchCode to ensure it is within the allowed range
    if (batchCode < 1000000 || batchCode > 9999999) {
      throw new Error("Batch Code must be between 1,000,000 and 9,999,999");
    }

    // Validate vendorId and ensure it's provided
    if (!vendorId) {
      throw new Error("Vendor ID is required");
    }

    // Insert batch with batch_code, batch_name, and v_id
    const query = `
      INSERT INTO batch (batch_code, batch_name, v_id) 
      VALUES ($1, $2, $3)
    `;

    await pool.query(query, [batchCode, batchName, vendorId]);
    console.log(
      "Batch inserted with code:",
      batchCode,
      "name:",
      batchName,
      "vendor ID:",
      vendorId
    );
  } catch (error) {
    console.error("Error inserting batch:", error.message);
    throw error;
  }
};

// Function to retrieve all batches
const getAllBatches = async () => {
  try {
    const res = await pool.query("SELECT * FROM batch");
    return res.rows.map((batch) => ({
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving batches:", error.message);
    throw error;
  }
};

// Function to retrieve a batch by ID
const getBatchById = async (batchId) => {
  try {
    const query = `SELECT * FROM batch WHERE b_id = $1`;
    const res = await pool.query(query, [batchId]);

    if (!res.rows.length) {
      throw new Error(`Batch with ID ${batchId} not found`);
    }

    const batch = res.rows[0];
    return {
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    };
  } catch (error) {
    console.error("Error retrieving batch:", error.message);
    throw error;
  }
};
const getAllBatchesByVendor = async (vendorId) => {
  try {
    console.log(`Fetching batches for vendor ID: ${vendorId}`);
    const query = `SELECT * FROM batch WHERE v_id = $1`;
    const res = await pool.query(query, [vendorId]);
    console.log("Vendor-specific batches fetched:", res.rows);
    return res.rows.map((batch) => ({
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving vendor-specific batches:", error.message);
    throw error;
  }
};

const insertFeatureProductMapping = async (f_id, p_id) => {
  try {
    const query = `INSERT INTO feature_product_map (f_id, p_id) VALUES ($1, $2)`;
    await pool.query(query, [f_id, p_id]);
    console.log("Feature-Product mapping added:", f_id, p_id);
  } catch (error) {
    console.error("Error inserting feature-product mapping:", error.message);
    throw error;
  }
};
const getFeaturesByProductId = async (productId) => {
  try {
    const query = `
      SELECT f.*
      FROM feature f
      JOIN feature_product_map fpm ON f.f_id = fpm.f_id
      JOIN product p ON p.p_id = fpm.p_id
      WHERE p.product_id = $1
    `;
    const res = await pool.query(query, [productId]);
    return res.rows;
  } catch (error) {
    console.error("Error retrieving features by product ID:", error.message);
    throw error;
  }
};
//----------------------------------------Mapping Feature Product-------------------------------------------------//
const getProductsWithFeaturesByVendor = async (vendorId) => {
  try {
    const query = `
  SELECT 
  p.product_id, 
  p.product_name, 
  f.feature_name
  FROM 
  product p
  JOIN 
  feature_product_map m ON p.p_id = m.p_id
  JOIN 
  feature f ON m.f_id = f.f_id
  WHERE 
  p.v_id = $1
  `;
    const result = await pool.query(query, [vendorId]);
    return result.rows.map((row) => ({
      productId: row.product_id,
      productName: row.product_name,
      featureName: row.feature_name,
    }));
  } catch (error) {
    console.error("Error retrieving products with features:", error.message);
    throw error;
  }
};

// Function to delete product and its related features
const deleteProductAndFeaturesByVendor = async (productId, vendorId) => {
  const client = await pool.connect();
  try {
    await client.query("BEGIN"); // Start transaction

    // Delete from feature_product_map
    const deleteFeatureMapQuery = `
      DELETE FROM feature_product_map
      WHERE p_id = $1
    `;
    await client.query(deleteFeatureMapQuery, [productId]);

    // Delete from product
    const deleteProductQuery = `
      DELETE FROM product
      WHERE p_id = $1 AND v_id = $2
    `;
    await client.query(deleteProductQuery, [productId, vendorId]);

    await client.query("COMMIT"); // Commit transaction
    return { success: true };
  } catch (error) {
    await client.query("ROLLBACK"); // Rollback transaction on error
    console.error("Error deleting product and features:", error.message);
    throw error;
  } finally {
    client.release(); // Release client
  }
};
//-----------------------entitlement and mapping-------------------------------------------//

// ** Database Functions **

// Function to insert a new entitlement
const insertEntitlement = async (entitlementId, date, vendorId) => {
  const query = `
    INSERT INTO entitlement (entitlement_id, date_created, v_id)
    VALUES ($1, $2, $3)
    RETURNING *;
  `;
  const values = [entitlementId, date, vendorId];
  const result = await pool.query(query, values);
  return result.rows[0]; // Returns the newly inserted entitlement, including the e_id
};


// Function to insert a product-entitlement mapping
const insertProductEntitlementMapping = async (
  entitlementId,
  productId,
  vendorId
) => {
  const query = `
    INSERT INTO product_ent_map (e_id, p_id, v_id)
    VALUES ($1, $2, $3);
  `;
  const values = [entitlementId, productId, vendorId];
  await pool.query(query, values);
};

const getEntitlementsByVendor = async (vendorId) => {
  try {
    const query = `
  SELECT 
  e.e_id,
  e.entitlement_id, 
  p.product_name,
  e.date_created
  FROM 
  entitlement e
  JOIN 
  product_ent_map pem ON e.e_id = pem.e_id
  JOIN 
  product p ON pem.p_id = p.p_id
  WHERE 
  pem.v_id = $1
  `;
    const result = await pool.query(query, [vendorId]);
    return result.rows.map((row) => ({
      eId:row.e_id,
      entitlementId: row.entitlement_id,
      productName: row.product_name,
      date: row.date_created, // Include date in the returned object
    }));
  } catch (error) {
    console.error(
      "Error retrieving entitlements with products:",
      error.message
    );
    throw error;
  }
};

const deleteEntitlementAndMappingsByVendor = async (eId, vendorId) => {
  const client = await pool.connect();
  try {
    await client.query("BEGIN"); // Start transaction

    // Delete from product_ent_map
    const deleteProductEntMapQuery = `
      DELETE FROM product_ent_map
      WHERE e_id = $1 AND v_id = $2
    `;
    await client.query(deleteProductEntMapQuery, [eId, vendorId]);

    // Delete from entitlement
    const deleteEntitlementQuery = `
      DELETE FROM entitlement
      WHERE e_id = $1
    `;
    await client.query(deleteEntitlementQuery, [eId]);

    await client.query("COMMIT"); // Commit transaction
    return { success: true };
  } catch (error) {
    await client.query("ROLLBACK"); // Rollback transaction on error
    console.error("Error deleting entitlement and mappings:", error.message);
    throw error;
  } finally {
    client.release(); // Release client
  }
};

// Function to delete entitlement and its related product mappings


// Export all functions for use in other files
module.exports = {
  pool,
  insertFeature,
  deleteFeature,
  getAllFeatureDetailsFromDb,
  getFeaturesByVendor,
  insertUserWithoutPassword,
  insertProduct,
  deleteProduct,
  getAllProducts,
  getUserByUserId,
  insertUser,
  insertUserBatch,
  getProductsByVendor,
  insertBatch,
  getAllBatches,
  getBatchById,
  getAllBatchesByVendor,
  getUserBatch,
  insertFeatureProductMapping,
  getFeaturesByProductId,
  insertMapping,
  getProductsWithFeaturesByVendor,
  insertEntitlement,
  insertProductEntitlementMapping,
  getEntitlementsByVendor,
  deleteProductAndFeaturesByVendor,
  deleteEntitlementAndMappingsByVendor,
};
----------------------------------------------------------------------------------

const express = require("express");
const {
  pool,
  insertUserBatch,
  getAllProducts,
} = require("./Database/Database"); // Ensure insertUserBatch is exported properly
const cors = require("cors");
const path = require("path");
const bodyParser = require("body-parser");
const morgan = require("morgan");
const jwt = require("jsonwebtoken");
const winston = require("winston");

const {
  insertFeature,
  deleteFeature,
  getAllFeatureDetailsFromDb,
  getFeaturesByVendor,
  insertUserWithoutPassword,
  insertProduct,
  deleteProduct,
  // getAllProductsFromDb,
  getUserByUserId,
  insertUser,
  getProductsByVendor,
  insertBatch,
  getAllBatches,
  getBatchById,
  insertFeatureProductMapping,
  getFeaturesByProductId,
  insertMapping,
  getProductsWithFeaturesByVendor,

  insertEntitlement,
  insertProductEntitlementMapping,
  getEntitlementsByVendor,
  deleteProductAndFeaturesByVendor,
  deleteEntitlementAndMappingsByVendor
} = require("./Database/Database");

const app = express();

// JWT Secret
const JWT_SECRET = "your_jwt_secret"; // Replace with a secure secret

// Logger setup
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: "error.log", level: "error" }),
    new winston.transports.File({ filename: "combined.log" }),
  ],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

// Middleware
app.use(cors());
app.use(express.json());
app.use(bodyParser.json());
app.use(
  morgan("combined", {
    stream: { write: (message) => logger.info(message.trim()) },
  })
);

// Middleware for authentication
const authorize = (roles) => (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ message: "Access token required" });
  }

  const token = authHeader.split(" ")[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET);

    if (!roles.includes(decoded.role)) {
      return res.status(403).json({ message: "Access forbidden" });
    }

    req.user = decoded; // Set user data for access in next route

    next();
  } catch (error) {
    res.status(401).json({ message: "Invalid token" });
  }
};

// ** User Authentication **

// Login endpoint
app.post("/api/login", async (req, res) => {
  const { userId, password } = req.body;

  if (!userId || !password) {
    return res
      .status(400)
      .json({ message: "User ID and password are required" });
  }

  try {
    const user = await getUserByUserId(userId);

    if (!user || user.password !== password) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const token = jwt.sign(
      { userId: user.user_id, role: user.role }, // Include role here
      JWT_SECRET,
      { expiresIn: "1h" }
    );

    res.json({ token });
  } catch (error) {
    logger.error(`Error during login: ${error.message}`, {
      stack: error.stack,
    });

    res.status(500).json({ message: "Server error. Please try again later." });
  }
});

// Endpoint to add a new user without a password
app.post("/api/add-user", async (req, res) => {
  const { userId, username } = req.body;

  if (!userId || !username) {
    return res
      .status(400)
      .json({ message: "User ID and username are required" });
  }

  try {
    await insertUserWithoutPassword(userId, username); // Ensure this function works as expected in Database.js
    res.status(201).json({ message: "User added successfully" });
  } catch (error) {
    logger.error(`Error adding user: ${error.message}`, { stack: error.stack });
    res.status(500).json({ message: "Server error. Please try again." });
  }
});

// ** Feature Endpoints **

// Get all features (Admin sees all, Vendor sees their own)
app.get("/api/features", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    const features =
      req.user.role === "vendor"
        ? await getFeaturesByVendor(req.user.userId)
        : await getAllFeatureDetailsFromDb();

    res.json({ features });
  } catch (error) {
    logger.error(`Error fetching features: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Add a new feature
app.post("/api/features", authorize(["admin", "vendor"]), async (req, res) => {
  const { featureId, featureName } = req.body;

  try {
    await insertFeature(featureId, featureName, req.user.userId);
    res.status(201).json({ message: "Feature added successfully" });
  } catch (error) {
    logger.error(`Error adding feature: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Delete a feature)
app.delete("/api/features/:featureId", async (req, res) => {
  try {
    console.log("Feature Id to delete:", req.params.featureId);
    await deleteFeature(req.params.featureId);
    res.status(200).json({ message: "Feature deleted successfully" });
  } catch (error) {
    console.error("Error deleting feature:", error.message);
    res.status(400).json({ message: error.message }); // Send the error message to the client
  }
});
// ** Product Endpoints **

// Get all products from the database
app.get("/api/products", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    const products =
      req.user.role === "vendor"
        ? await getProductsByVendor(req.user.userId)
        : await getAllProducts();

    res.json({ products });
  } catch (error) {
    logger.error(`Error fetching products: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Add a new product to the database
app.post("/api/products", authorize(["admin", "vendor"]), async (req, res) => {
  const { productId, productName, features } = req.body; // Include features in the request body

  try {
    // Insert the new product
    const newProduct = await insertProduct(
      productId,
      productName,
      req.user.userId
    );

    // Insert mappings if features are provided
    if (features && features.length > 0) {
      for (let featureId of features) {
        await insertMapping(featureId, newProduct.p_id, req.user.userId);
      }
    }

    res.status(201).json({
      message: "Product and associated features added successfully",
      newProduct,
    });
  } catch (error) {
    logger.error(`Error adding product: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Delete a product from the database
app.delete("/api/products/:productId", async (req, res) => {
  try {
    console.log("Product ID to delete:", req.params.productId); // Debug log
    await deleteProduct(req.params.productId);
    res.status(200).json({ message: "Product deleted successfully" });
  } catch (error) {
    console.error("Error during product deletion:", error.message); // Log error
    res.status(400).json({ message: error.message }); // Send error to the client
  }
});

// Add user to batch
app.post("/api/add-user-batch", async (req, res) => {
  const { userId, username, batchCode } = req.body;

  try {
    // Insert the user into the users table
    await insertUser(userId, username, ""); // Assuming no password is provided

    // Fetch the batch ID using the batch code
    const batch = await getBatchByCode(batchCode);
    if (!batch) {
      return res.status(400).json({ message: "Invalid batch code" });
    }

    // Insert into user_batch table
    await insertUserBatch(userId, batch.b_id);

    res.status(200).json({ message: "User batch added successfully!" });
  } catch (error) {
    console.error("Error in adding user batch:", error.message);
    logger.error(`Error in adding user batch: ${error.message}`, {
      stack: error.stack,
    });
    res
      .status(500)
      .json({ error: "Failed to add user batch. Please try again." });
  }
});

// Helper function to get batch by code
const getBatchByCode = async (batchCode) => {
  try {
    const query = `SELECT * FROM batch WHERE batch_code = $1`;
    const res = await pool.query(query, [batchCode]);
    return res.rows[0];
  } catch (error) {
    console.error("Error retrieving batch by code:", error.message);
    throw error;
  }
};

// Endpoint to add a new batch
app.post("/api/batches", authorize(["admin", "vendor"]), async (req, res) => {
  const { batchCode, batchName } = req.body;

  if (!batchCode) {
    return res.status(400).json({ message: "Batch Code is required" });
  }

  if (batchCode < 1000000 || batchCode > 9999999) {
    return res
      .status(400)
      .json({ message: "Batch Code must be between 1,000,000 and 9,999,999" });
  }

  try {
    const vendorId = req.user.userId;

    await insertBatch(batchCode, vendorId, batchName);
    res.status(201).json({ message: "Batch added successfully!" });
  } catch (error) {
    logger.error(`Error adding batch: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: "Failed to add batch. Please try again." });
  }
});

// Endpoint to fetch all batches
app.get("/api/batches", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    let batches;

    if (req.user.role === "vendor") {
      const vendorId = req.user.userId;
      console.log(`Fetching batches for vendor ID: ${vendorId}`);
      batches = await getAllBatchesByVendor(vendorId);
    } else {
      console.log("Fetching all batches for admin");
      batches = await getAllBatches();
    }

    console.log("Batches retrieved:", batches);
    res.status(200).json({ batches });
  } catch (error) {
    console.error("Error retrieving batches:", error.message);
    logger.error(`Error retrieving batches: ${error.message}`, {
      stack: error.stack,
    });
    res
      .status(500)
      .json({ message: "Failed to retrieve batches. Please try again." });
  }
});

// Endpoint to retrieve a batch by ID
app.get(
  "/api/batches/:batchId",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    const { batchId } = req.params;

    try {
      const batch = await getBatchById(batchId);

      if (!batch) {
        return res.status(404).json({ message: "Batch not found" });
      }

      // Restrict access to the vendor's own batches
      if (req.user.role === "vendor" && batch.vendorId !== req.user.userId) {
        return res.status(403).json({ message: "Access forbidden" });
      }

      res.status(200).json({ batch });
    } catch (error) {
      logger.error(`Error retrieving batch: ${error.message}`, {
        stack: error.stack,
      });
      res
        .status(500)
        .json({ message: "Failed to retrieve batch. Please try again." });
    }
  }
);

// Update the getAllBatches function to support vendor-specific filtering
const getAllBatchesByVendor = async (vendorId) => {
  try {
    const query = `SELECT * FROM batch WHERE v_id = $1`;
    const res = await pool.query(query, [vendorId]);

    return res.rows.map((batch) => ({
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving vendor-specific batches:", error);
    throw error;
  }
};

//-------------------------------------Get Product Feature Mapping-------------------------------
app.get(
  "/api/products-with-features",
  authorize(["vendor"]),
  async (req, res) => {
    try {
      const products = await getProductsWithFeaturesByVendor(req.user.userId);
      res.json({ products });
    } catch (error) {
      logger.error(`Error fetching products with features: ${error.message}`, {
        stack: error.stack,
      });
      res.status(500).json({ message: error.message });
    }
  }
);
// API endpoint to delete product and related features
app.delete(
  "/api/products/:productId",
  authorize(["vendor"]),
  async (req, res) => {
    const { productId } = req.params;
    const vendorId = req.user.userId;

    try {
      const result = await deleteProductAndFeaturesByVendor(
        productId,
        vendorId
      );
      res.json({
        message: "Product and related features deleted successfully.",
        result,
      });
    } catch (error) {
      logger.error(`Error deleting product and features: ${error.message}`, {
        stack: error.stack,
      });
      res
        .status(500)
        .json({ message: "Failed to delete product and features." });
    }
  }
);

//-------------------------------------Get Product Ent Mapping-------------------------------

// Get all entitlements

// Add a new entitlement and product mapping to the database
app.post(
  "/api/entitlements",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    const { entitlementId, dates, selectedProducts } = req.body;

    console.log("Received data:", req.body); // Log incoming request body

    try {
      const vendorId = req.user.userId;

      // Validate and format the dates
      const formattedDates = Array.isArray(dates) ? dates : [dates];
      const formattedTimestamps = formattedDates.map((date) => {
        const parsedDate = new Date(date);
        if (isNaN(parsedDate)) {
          throw new Error(`Invalid date value: ${date}`);
        }
        return parsedDate.toISOString(); // Convert to ISO string
      });

      // Insert the new entitlement
      const newEntitlement = await insertEntitlement(
        entitlementId,
        formattedTimestamps,
        vendorId
      );
      console.log("New Entitlement:", newEntitlement);

      // Validate selectedProducts
      if (!selectedProducts || selectedProducts.length === 0) {
        console.warn("No selected products provided for mapping.");
        return res
          .status(400)
          .json({ message: "No products selected for mapping." });
      }

      // Insert mappings to product_ent_map table
      const failedMappings = [];
      for (let productId of selectedProducts) {
        try {
          console.log("Mapping entitlement to product:", {
            entitlementId: newEntitlement.e_id,
            productId,
            vendorId: req.user.userId,
          });

          // Insert mapping into product_ent_map
          await insertProductEntitlementMapping(
            newEntitlement.e_id,
            productId,
            req.user.userId
          );
        } catch (mappingError) {
          console.error(
            `Error adding product mapping for product ID ${productId}:`,
            mappingError.message
          );
          failedMappings.push(productId); // Keep track of failed mappings
        }
      }

      // If any mappings failed, return a partial success response
      if (failedMappings.length > 0) {
        console.warn("Failed mappings for product IDs:", failedMappings);
        return res.status(500).json({
          message: "Entitlement added, but some product mappings failed.",
          failedMappings,
        });
      }

      // Return success response
      res.status(201).json({
        message: "Entitlement and associated products added successfully.",
        newEntitlement,
      });
    } catch (error) {
      console.error("Error adding entitlement:", error); // Log the full error
      res.status(500).json({ message: error.message });
    }
  }
);

app.get(
  "/api/entitlements-with-products",
  authorize(["vendor"]), // Assuming `authorize` middleware checks if the user is a vendor
  async (req, res) => {
    try {
      const entitlements = await getEntitlementsByVendor(req.user.userId);
      res.json({ entitlements });
    } catch (error) {
      logger.error(
        `Error fetching entitlements with products: ${error.message}`,
        {
          stack: error.stack,
        }
      );
      res.status(500).json({ message: error.message });
    }
  }
);

app.delete(
  "/api/entitlements/:eId", // Use `eId` in the route
  authorize(["vendor"]),
  async (req, res) => {
    const { eId } = req.params; // Get `eId` from params
    const vendorId = req.user.userId;

    try {
      const result = await deleteEntitlementAndMappingsByVendor(eId, vendorId);
      res.json({
        message: "Entitlement and related mappings deleted successfully.",
        result,
      });
    } catch (error) {
      logger.error(`Error deleting entitlement and mappings: ${error.message}`, {
        stack: error.stack,
      });
      res
        .status(500)
        .json({ message: "Failed to delete entitlement and mappings." });
    }
  }
);




// Serve static files from the React app
app.use(express.static(path.join(__dirname, "../Frontend")));

// Handle all other requests by sending the React app
app.get("*", (req, res) => {
  res.sendFile(path.join(__dirname, "../Frontend", "index.html"));
});

// 404 route for undefined endpoints
app.use((req, res) => {
  logger.warn("Attempted to access undefined endpoint");
  res.status(404).send("Endpoint not found");
});

// Use environment variable for port or default to 5001
const port = process.env.PORT || 5001;

app.listen(port, () => {
  logger.info(`Server running on port ${port}`);
});
-----------------------------------------------------------------------------------
import React, { useState, useEffect } from "react";
import axios from "axios";
import { useFormik } from "formik";
import DeleteIcon from "@mui/icons-material/Delete";
import { ToastContainer, toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import {
  TextField,
  Button,
  Container,
  IconButton,
  CardContent,
  Card,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Box,
  CircularProgress,
  Alert,
} from "@mui/material";
const LicenseComponent = () => {
  const [features, setFeatures] = useState([]);
  const [loading, setLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [successMessage, setSuccessMessage] = useState("");
  const token = localStorage.getItem("token"); // Retrieve token
  // Fetch features from the database
  useEffect(() => {
    const fetchFeatures = async () => {
      try {
        const response = await axios.get("http://localhost:5001/api/features", {
          headers: { Authorization: `Bearer ${token}` },
        });
        setFeatures(response.data.features || []);
      } catch (error) {
        toast.error("Error loading features from the database");
      } finally {
        setLoading(false);
      }
    };
    fetchFeatures();
  }, [token]);
  // Formik for adding features
  const formik = useFormik({
    initialValues: {
      featureId: "",
      featureName: "",
    },
    onSubmit: async (values, { resetForm }) => {
      setSubmitLoading(true);
      setSuccessMessage("");
      try {
        const newFeature = {
          featureId: values.featureId,
          featureName: values.featureName,
        };
        // Add the new feature to the database
        await axios.post("http://localhost:5001/api/features", newFeature, {
          headers: { Authorization: `Bearer ${token}` },
        });
        setFeatures((prevFeatures) => [...prevFeatures, newFeature]);
        setSuccessMessage("Feature added successfully!");
        resetForm();
      } catch (error) {
        toast.error(error.response?.data?.message || "Error adding feature");
      } finally {
        setSubmitLoading(false);
      }
    },
  });
  // Delete a feature
  const handleDelete = async (featureId) => {
    try {
      const response = await axios.delete(
        `http://localhost:5001/api/features/${featureId}`,
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      setFeatures((prevFeatures) =>
        prevFeatures.filter((feature) => feature.featureId !== featureId)
      );
      setSuccessMessage("Feature deleted successfully!");
    } catch (error) {
      // Display backend error message
      const errorMessage =
        error.response?.data?.message || "Error deleting feature.";
      console.error("delete error", errorMessage);
      toast.error(errorMessage);
    }
  };

  if (loading) return <CircularProgress />;
  return (
    <Container>
      <Box sx={{ mt: 4, mb: 2 }}>
        <Typography variant="h4" gutterBottom>
          Add New Feature
        </Typography>
        <form onSubmit={formik.handleSubmit}>
          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
            <TextField
              label="Feature ID"
              variant="outlined"
              name="featureId"
              type="text"
              value={formik.values.featureId}
              onChange={formik.handleChange}
              onBlur={formik.handleBlur}
              error={
                formik.touched.featureId && Boolean(formik.errors.featureId)
              }
              helperText={formik.touched.featureId && formik.errors.featureId}
              fullWidth
            />
            <TextField
              label="Feature Name"
              variant="outlined"
              name="featureName"
              type="text"
              value={formik.values.featureName}
              onChange={formik.handleChange}
              onBlur={formik.handleBlur}
              error={
                formik.touched.featureName && Boolean(formik.errors.featureName)
              }
              helperText={
                formik.touched.featureName && formik.errors.featureName
              }
              fullWidth
            />
          </Box>
          <Box sx={{ mt: 2 }}>
            <Button
              type="submit"
              variant="contained"
              color="primary"
              disabled={submitLoading}
            >
              {submitLoading ? <CircularProgress size={24} /> : "Add Feature"}
            </Button>
          </Box>
        </form>
        {successMessage && (
          <Alert severity="success" sx={{ mt: 2 }}>
            {successMessage}
          </Alert>
        )}
      </Box>
      <Card>
        <CardContent>
          <Typography variant="h5" gutterBottom sx={{ mt: 4 }}>
            Feature List
          </Typography>
          <Paper>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Feature ID</TableCell>
                  <TableCell>Feature Name</TableCell>
                  <TableCell width={7}></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {features.length > 0 ? (
                  features.map((feature) => (
                    <TableRow key={feature.featureId}>
                      <TableCell>{feature.featureId}</TableCell>
                      <TableCell>{feature.featureName}</TableCell>
                      <TableCell>
                        <IconButton
                          onClick={() => handleDelete(feature.featureId)}
                        >
                          <DeleteIcon />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={3} align="center">
                      Nothing added yet
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </Paper>
        </CardContent>
      </Card>
      <ToastContainer />
    </Container>
  );
};
export default LicenseComponent;

