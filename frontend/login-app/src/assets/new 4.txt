const express = require("express");
const {
  pool,
  insertUserBatch,
  getAllProducts,
} = require("./Database/Database"); // Ensure insertUserBatch is exported properly
const cors = require("cors");
const path = require("path");
const bodyParser = require("body-parser");
const morgan = require("morgan");
const jwt = require("jsonwebtoken");
const winston = require("winston");

const {
  insertFeature,
  deleteFeature,
  getAllFeatureDetailsFromDb,
  getFeaturesByVendor,
  insertUserWithoutPassword,
  insertProduct,
  deleteProduct,
  // getAllProductsFromDb,
  getUserByUserId,
  insertUser,
  getProductsByVendor,
  insertBatch,
  getAllBatches,
  getBatchById,
  getAllBatchesByVendor,
  insertFeatureProductMapping,
  getFeaturesByProductId,
  insertMapping,
  getProductsWithFeaturesByVendor,
  deleteEntitlement,
  insertEntitlement,
  insertProductEntitlementMapping,
  getEntitlementsByVendor,
  deleteProductAndFeaturesByVendor,
} = require("./Database/Database");

const app = express();

// JWT Secret
const JWT_SECRET = "your_jwt_secret"; // Replace with a secure secret

// Logger setup
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: "error.log", level: "error" }),
    new winston.transports.File({ filename: "combined.log" }),
  ],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

// Middleware
app.use(cors());
app.use(express.json());
app.use(bodyParser.json());
app.use(
  morgan("combined", {
    stream: { write: (message) => logger.info(message.trim()) },
  })
);

// Generate JWT token with vendorId
const generateToken = (user) => {
  return jwt.sign(
    { userId: user.u_id, role: user.role, vendorId: user.v_id },
    // Include vendorId in the token payload
    JWT_SECRET,
    { expiresIn: "1h" }
  );
};

// Middleware for authentication
const authorize = (roles) => (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ message: "Access token required" });
  }

  const token = authHeader.split(" ")[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET);

    if (!roles.includes(decoded.role)) {
      return res.status(403).json({ message: "Access forbidden" });
    }

    req.user = decoded; // Set user data for access in next route
    console.log("req.user in authorize:", req.user);
    next();
  } catch (error) {
    res.status(401).json({ message: "Invalid token" });
  }
};

// ** User Authentication **

// Login endpoint
app.post("/api/login", async (req, res) => {
  const { userId, password } = req.body;
  if (!userId || !password) {
    return res
      .status(400)
      .json({ message: "User ID and password are required" });
  }
  try {
    const user = await getUserByUserId(userId);
    if (!user || user.password !== password) {
      return res.status(401).json({ message: "Invalid credentials" });
    }
    const token = generateToken(user);

    res.json({
      token,
      userId: user.u_id,
      vendorId: user.v_id,
      role: user.role,
    });
  } catch (error) {
    logger.error(`Error during login: ${error.message}`, {
      stack: error.stack,
    });

    res.status(500).json({ message: "Server error. Please try again later." });
  }
});

// Endpoint to add a new user without a password
app.post("/api/add-user", async (req, res) => {
  const { userId, username } = req.body;

  if (!userId || !username) {
    return res
      .status(400)
      .json({ message: "User ID and username are required" });
  }

  try {
    await insertUserWithoutPassword(userId, username); // Ensure this function works as expected in Database.js
    res.status(201).json({ message: "User added successfully" });
  } catch (error) {
    logger.error(`Error adding user: ${error.message}`, { stack: error.stack });
    res.status(500).json({ message: "Server error. Please try again." });
  }
});

// ** Feature Endpoints **

// Get all features (Admin sees all, Vendor sees their own)
// app.js

app.get("/api/features", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    let features;

    if (req.user.role === "vendor") {
      const vendorId = req.user.vendorId; // Or req.user.v_id - use the correct property from JWT
      features = await getFeaturesByVendor(vendorId); // Correct: Use getFeaturesByVendor
    } else {
      // Admin
      features = await getAllFeatureDetailsFromDb();
    }

    console.log("Features being returned from /api/features:", features); // Log the actual features
    res.json({ features });
  } catch (error) {
    logger.error(`Error fetching features: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Add a new feature
app.post("/api/features", authorize(["admin", "vendor"]), async (req, res) => {
  const { featureId, featureName } = req.body;
  try {
    // Fetch v_id of the logged-in user
    const userQuery = `SELECT v_id FROM users WHERE u_id = $1`;
    const userResult = await pool.query(userQuery, [req.user.userId]);
    if (userResult.rows.length === 0) {
      return res.status(404).json({ message: "User not found" });
    }
    const vendorId = userResult.rows[0].v_id;
    if (!vendorId) {
      return res.status(400).json({ message: "Vendor ID not set for user" });
    }
    // Call the function to insert the feature with the vendor ID
    await insertFeature(featureId, featureName, vendorId);
    res.status(201).json({ message: "Feature added successfully" });
  } catch (error) {
    logger.error(`Error adding feature: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Delete a feature)
// app.js
app.delete("/api/features/:featureId", async (req, res) => {
  try {
    console.log("Feature Id to delete:", req.params.featureId);
    await deleteFeature(req.params.featureId);
    res.status(200).json({ message: "Feature deleted successfully" });
  } catch (error) {
    console.error("Error deleting feature:", error.message);
    res.status(400).json({ message: error.message }); // Send the error message to the client
  }
});
// ** Product Endpoints **

// Get all products from the database
app.get("/api/products", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    if (req.user.role === "vendor") {
      const vendorId = req.user.vendorId; // From JWT
      const products = await getProductsByVendor(vendorId);
      console.log("Products", products);
      res.json({ products });
    } else {
      const { vendorId } = req.query; // Get vendorId from query parameter
      if (!vendorId) {
        return res
          .status(400)
          .json({ message: "Vendor ID is required for admin." });
      }
      const products = await getProductsByVendor(vendorId); //Get products for the specified vendor

      res.json({ products });
    }
  } catch (error) {
    logger.error(`Error fetching products: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: error.message });
  }
});

// Add a new product to the database

app.post("/api/products", authorize(["admin", "vendor"]), async (req, res) => {
  const { productId, productName, features } = req.body;

  try {
    const vendorId = req.user.vendorId; // Use vendorId from decoded JWT

    if (!vendorId) {
      return res.status(400).json({ message: "Vendor ID is required" });
    }

    const newProduct = await insertProduct(productId, productName, vendorId);

    if (features && features.length > 0) {
      for (let featureId of features) {
        await insertMapping(featureId, newProduct.p_id, vendorId);
      }
    }

    res.status(201).json({
      message: "Product and associated features added successfully",

      newProduct,
    });
  } catch (error) {
    logger.error(`Error adding product: ${error.message}`, {
      stack: error.stack,
    });

    res.status(500).json({ message: error.message });
  }
});

// Delete a product from the database
// Delete a product from the database
app.delete(
  "/api/products/:productId",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    try {
      const productIdToDelete = parseInt(req.params.productId, 10); // Parse to integer

      // Check if the product is used in any entitlements
      const entitlementUsage = await pool.query(
        "SELECT COUNT(*) AS entitlement_count FROM product_ent_map WHERE p_id = $1", // Parameterize
        [productIdToDelete]
      );

      const entitlementCount = parseInt(
        entitlementUsage.rows[0].entitlement_count,
        10
      );

      if (entitlementCount > 0) {
        return res.status(400).json({
          message:
            "Cannot delete product. It is used in one or more entitlements.",
        });
      }

      // Proceed with deletion if not used in any entitlement
      await deleteProduct(productIdToDelete); // Assuming deleteProduct takes p_id
      res.status(200).json({ message: "Product deleted successfully." });
    } catch (error) {
      console.error("Error deleting product:", error.message); // Log full error for debugging
      res.status(500).json({
        message:
          "Cannot delete product. It is used in one or more entitlements.",
        details: error.message,
      }); // Send error details to the client
    }
  }
);

// Add user to batch
app.post(
  "/api/add-user-batch",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    try {
      const { userId, username, batchCode } = req.body;
      let vendorId;

      if (req.user.role === "vendor") {
        vendorId = req.user.vendorId; // Correct: from JWT
      } else if (req.user.role === "admin") {
        vendorId = req.body.vendorId; // Correct: from request body for admin
      }

      // Validate userId, username, batchCode, and vendorId
      if (!userId || !username || !batchCode || !vendorId) {
        // Validate all required fields
        return res.status(400).json({
          message:
            "All fields (userId, username, batchCode, vendorId) are required.",
        });
      }

      const newUserId = await insertUser(userId, username, "", vendorId);

      const batch = await getBatchByCode(batchCode);

      if (!batch) {
        return res.status(404).json({ message: "Batch not found." }); // More specific error
      }

      await insertUserBatch(newUserId, batch.b_id); // Use newUserId!

      res.status(201).json({
        message: "User added to batch successfully!",
        userId: newUserId,
        batchId: batch.b_id,
      }); // Success response with details
    } catch (error) {
      console.error("Error adding user to batch:", error); // Log the full error object for more details

      if (error.code === "23505") {
        if (error.detail.includes("user_id")) {
          return res
            .status(400)
            .json({ message: "User already exists in batch" });
        }
      }

      res.status(500).json({
        message: "Failed to add user to batch.",
        details: error.message,
      }); // More informative response
    }
  }
);

// Helper function to get batch by code
const getBatchByCode = async (batchCode) => {
  try {
    const query = `SELECT * FROM batch WHERE batch_code = $1`;
    const res = await pool.query(query, [batchCode]);
    return res.rows[0];
  } catch (error) {
    console.error("Error retrieving batch by code:", error.message);
    throw error;
  }
};

// Endpoint to add a new batch
app.post("/api/batches", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    const { batchCode, batchName } = req.body;

    // Fetch v_id of the logged-in user
    const userQuery = `SELECT v_id FROM users WHERE u_id = $1`;
    const userResult = await pool.query(userQuery, [req.user.userId]);

    if (userResult.rows.length === 0) {
      return res.status(404).json({ message: "User not found" });
    }

    const vendorId = userResult.rows[0].v_id;

    if (!vendorId) {
      return res.status(400).json({ message: "Vendor ID not set for user" });
    }

    // Insert batch
    await insertBatch(batchCode, batchName, vendorId);

    res.status(201).json({ message: "Batch added successfully!" });
  } catch (error) {
    console.error("Error adding batch:", error);
    res
      .status(500)
      .json({ message: "Internal Server Error", details: error.message });
  }
});

// Endpoint to fetch all batches
app.get("/api/batches", authorize(["admin", "vendor"]), async (req, res) => {
  try {
    let batches;
    if (req.user.role === "vendor") {
      const vendorId = req.user.vendorId; //Directly use vendorId
      batches = await getAllBatchesByVendor(vendorId);
    } else {
      //Admin Case
      batches = await getAllBatches();
    }
    console.log("Batches retrieved:", batches); //Check after retrieval
    res.status(200).json({ batches });
  } catch (error) {
    logger.error(`Error fetching batches: ${error.message}`, {
      stack: error.stack,
    });
    res.status(500).json({ message: "Failed to fetch batches." });
  }
});

// Endpoint to retrieve a batch by ID
app.get(
  "/api/batches/:batchId",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    const { batchId } = req.params;

    try {
      const batch = await getBatchById(batchId);

      if (!batch) {
        return res.status(404).json({ message: "Batch not found" });
      }

      // Restrict access to the vendor's own batches
      if (req.user.role === "vendor" && batch.vendorId !== req.user.v_id) {
        return res.status(403).json({ message: "Access forbidden" });
      }

      res.status(200).json({ batch });
    } catch (error) {
      logger.error(`Error retrieving batch: ${error.message}`, {
        stack: error.stack,
      });
      res
        .status(500)
        .json({ message: "Failed to retrieve batch. Please try again." });
    }
  }
);

//-------------------------------------Get Product Feature Mapping-------------------------------
app.get(
  "/api/products-with-features",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    try {
      let products;

      if (req.user.role === "vendor") {
        const vendorId = req.user.vendorId; // Extract vendorId from JWT payload
        console.log("Fetching products with features for vendor ID:", vendorId);
        products = await getProductsWithFeaturesByVendor(vendorId);
      } else {
        // Implement getAllProductsWithFeatures() for admin if required
        console.log("Fetching all products with features for admin");
        products = await getAllProductsWithFeatures();
      }

      // Debug fetched products
      console.log("Products fetched successfully:", products);
      res.json({ products });
    } catch (error) {
      logger.error(`Error fetching products with features: ${error.message}`, {
        stack: error.stack,
      });
      res
        .status(500)
        .json({ message: "Failed to fetch products with features" });
    }
  }
);
// API endpoint to delete product and related features
app.delete(
  "/api/products/:productId",
  authorize(["vendor"]),
  async (req, res) => {
    const { productId } = req.params;
    const vendorId = req.user.u_id;

    try {
      const result = await deleteProductAndFeaturesByVendor(
        productId,
        vendorId
      );
      res.json({
        message: "Product and related features deleted successfully.",
        result,
      });
    } catch (error) {
      logger.error(`Error deleting product and features: ${error.message}`, {
        stack: error.stack,
      });
      res
        .status(500)
        .json({ message: "Failed to delete product and features." });
    }
  }
);

//-------------------------------------Get Product Ent Mapping-------------------------------

// Get all entitlements

// Add a new entitlement and product mapping to the database
app.post(
  "/api/entitlements",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    try {
      const { entitlementId, dates, selectedProducts } = req.body;
      const vendorId = req.user.vendorId; // From JWT
      console.log("Received data:", req.body); // Log incoming request body

      // Validate and format the dates
      const formattedDates = Array.isArray(dates) ? dates : [dates];
      const formattedTimestamps = formattedDates.map((date) => {
        const parsedDate = new Date(date);
        if (isNaN(parsedDate)) {
          throw new Error(`Invalid date value: ${date}`);
        }
        return parsedDate.toISOString(); // Convert to ISO string
      });

      // Insert the new entitlement
      const newEntitlement = await insertEntitlement(
        entitlementId,
        formattedTimestamps,
        vendorId
      );
      console.log("New Entitlement:", newEntitlement);

      // Validate selectedProducts
      if (!selectedProducts || selectedProducts.length === 0) {
        console.warn("No selected products provided for mapping.");
        return res
          .status(400)
          .json({ message: "No products selected for mapping." });
      }

      // Insert mappings to product_ent_map table
      const failedMappings = [];
      for (let productId of selectedProducts) {
        try {
          console.log("Mapping entitlement to product:", {
            entitlementId: newEntitlement.e_id,
            productId,
            vendorId: req.user.u_id,
          });

          // Insert mapping into product_ent_map
          await insertProductEntitlementMapping(
            newEntitlement.e_id,
            productId,
            req.user.u_id
          );
        } catch (mappingError) {
          console.error(
            `Error adding product mapping for product ID ${productId}:`,
            mappingError.message
          );
          failedMappings.push(productId); // Keep track of failed mappings
        }
      }

      // If any mappings failed, return a partial success response
      if (failedMappings.length > 0) {
        console.warn("Failed mappings for product IDs:", failedMappings);
        return res.status(500).json({
          message: "Entitlement added, but some product mappings failed.",
          failedMappings,
        });
      }

      // Return success response
      res.status(201).json({
        message: "Entitlement and associated products added successfully.",
        newEntitlement,
      });
    } catch (error) {
      console.error("Error adding entitlement:", error); // Log the full error
      res.status(500).json({ message: error.message });
    }
  }
);

app.get(
  "/api/entitlements-with-products",
  authorize(["vendor"]), // Assuming `authorize` middleware checks if the user is a vendor
  async (req, res) => {
    try {
      const vendorId = req.user.vendorId;
      const entitlements = await getEntitlementsByVendor(vendorId);
      console.log("Entitlements fetched:", entitlements);

      res.json({ entitlements });
    } catch (error) {
      logger.error(
        `Error fetching entitlements with products: ${error.message}`,
        {
          stack: error.stack,
        }
      );
      res.status(500).json({ message: error.message });
    }
  }
);

// Delete an entitlement from the database
"/api/entitlements/:entitlementId",
  authorize(["admin", "vendor"]),
  async (req, res) => {
    try {
      const entitlementIdToDelete = parseInt(req.params.entitlementId, 10); // Parse to integer

      if (isNaN(entitlementIdToDelete)) {
        return res.status(400).json({ message: "Invalid entitlement ID" });
      }

      // Proceed with deletion
      await deleteEntitlement(entitlementIdToDelete); // Assuming deleteEntitlement takes e_id
      res.status(200).json({ message: "Entitlement deleted successfully." });
    } catch (error) {
      console.error("Error deleting entitlement:", error.message); // Log full error for debugging
      res.status(500).json({
        message: "Failed to delete entitlement.",
        details: error.message,
      }); // Send error details to the client
    }
  };

// Serve static files from the React app
app.use(express.static(path.join(__dirname, "../Frontend")));

// Handle all other requests by sending the React app
app.get("*", (req, res) => {
  res.sendFile(path.join(__dirname, "../Frontend", "index.html"));
});

// 404 route for undefined endpoints
app.use((req, res) => {
  logger.warn("Attempted to access undefined endpoint");
  res.status(404).send("Endpoint not found");
});

// Use environment variable for port or default to 5001
const port = process.env.PORT || 5001;

app.listen(port, () => {
  logger.info(`Server running on port ${port}`);
});

---------------------------------------------------------------------------------------

const { Pool } = require("pg");

// Database configuration
const config = {
  user: "postgres", // Database username
  host: "localhost", // Database host
  database: "licensesolution", // Database name
  password: "Pass@123", // Database password
  port: 5433, // Database port (make sure this is correct)
};

// Initialize the Pool for better performance
const pool = new Pool(config);

// Test the connection
pool
  .connect()
  .then((client) => {
    console.log("Database connected successfully");
    client.release();
  })
  .catch((err) => console.error("Error connecting to the database:", err));

// Function to insert a new user without a password
const insertUserWithoutPassword = async (userId, username) => {
  try {
    const role = "end-user"; // Default role
    console.log(
      `Inserting user with ID: ${userId}, Username: ${username}, Role: ${role}`
    );
    const query = `INSERT INTO users (user_id, username, role) VALUES ($1, $2, $3)`;
    await pool.query(query, [userId, username, role]);
    console.log("User inserted:", userId, username, role);
  } catch (error) {
    console.error("Error inserting user:", error.message);
    throw error;
  }
};

// Function to insert a new feature

const insertFeature = async (featureId, featureName, vendorId) => {
  try {
    console.log("Fetching v_id for user_id:", vendorId);
    // Validate featureId
    if (
      !featureId ||
      typeof featureId !== "string" ||
      featureId.trim() === ""
    ) {
      throw new Error("Invalid Feature ID. It must be a non-empty string.");
    }
    // Check if the feature already exists for the given vendor
    const existingFeature = await pool.query(
      "SELECT * FROM feature WHERE feature_id = $1 AND v_id = $2",

      [featureId, vendorId]
    );
    if (existingFeature.rows.length > 0) {
      throw new Error("Feature with this ID already exists for the vendor.");
    }
    // Insert the new feature
    const insertQuery = `INSERT INTO feature (feature_id, feature_name, v_id) VALUES ($1, $2, $3)`;
    await pool.query(insertQuery, [featureId, featureName, vendorId]);
    console.log("Feature inserted:", featureId, featureName, vendorId);
  } catch (error) {
    console.error("Error inserting feature:", error.message);

    throw error; // Rethrow the error so the calling function can handle it
  }
};

// Function to delete a feature
const deleteFeature = async (featureId) => {
  try {
    // Get `f_id` from `feature_id`
    const feature = await pool.query(
      `SELECT f_id FROM feature WHERE f_id = $1`,
      [featureId]
    );
    if (feature.rows.length === 0) {
      throw new Error("Feature not found.");
    }
    const f_id = feature.rows[0].f_id;
    // Check if `f_id` is linked in `feature_product_map`
    const linkedProduct = await pool.query(
      `SELECT * FROM feature_product_map WHERE f_id = $1`,
      [f_id]
    );
    console.log("Linked Product:", linkedProduct.rows); // Debug log

    if (linkedProduct.rows.length > 0) {
      throw new Error("Feature is linked to a product and cannot be deleted.");
    }

    // Proceed with deletion if no linked products

    const deleteQuery = `DELETE FROM feature WHERE f_id = $1`;

    await pool.query(deleteQuery, [f_id]);

    console.log("Feature deleted:", f_id);
  } catch (error) {
    console.error("Error deleting feature:", error.message);

    throw error;
  }
};

// Function to get all feature details from the database
const getAllFeatureDetailsFromDb = async () => {
  try {
    const featureRes = await pool.query(
      "SELECT f_id, feature_id, feature_name, v_id FROM feature"
    );
    return featureRes.rows.map((feature) => ({
      f_id: feature.f_id,
      featureId: feature.feature_id,
      featureName: feature.feature_name,
      vendorId: feature.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving features:", error.message);
    throw error;
  }
};

// Function to get features by vendor
const getFeaturesByVendor = async (vendorId) => {
  try {
    console.log("Retrieving features for vendor:", vendorId);
    const query =
      "SELECT f_id, feature_id, feature_name FROM feature WHERE v_id = $1";
    const res = await pool.query(query, [vendorId]);
    return res.rows.map((feature) => ({
      f_id: feature.f_id,
      featureId: feature.feature_id,
      featureName: feature.feature_name,
    }));
  } catch (error) {
    console.error("Error retrieving vendor features:", error.message);
    throw error;
  }
};

// Function to insert a user (with role validation)
const insertUser = async (
  userId,
  username,
  password,
  vendorId,
  role = "end-user"
) => {
  try {
    if (!vendorId) {
      // Check if vendorId is valid
      throw new Error("Vendor ID is required when adding a user.");
    }
    const query = `INSERT INTO users (user_id, username, password,v_id, role) VALUES ($1, $2, $3, $4, $5)`;
    await pool.query(query, [userId, username, password, vendorId, role]);
    console.log("User inserted:", userId, username, vendorId, role);
  } catch (error) {
    console.error("Error inserting user:", error.message);
    throw error;
  }
};

// Function to insert user into user_batch table
const insertUserBatch = async (userId, batchId) => {
  try {
    const query = `INSERT INTO user_batch_map (u_id, b_id) VALUES ($1, $2)`;
    await pool.query(query, [userId, batchId]);
    console.log("User added to batch:", userId, batchId);
  } catch (error) {
    console.error("Error inserting into user_batch_map:", error.message);
    throw error;
  }
};

const getUserBatch = async (userId) => {
  try {
    const query = `SELECT * FROM user_batch_map WHERE user_id = $1`;
    const res = await pool.query(query, [userId]);
    return res.rows;
  } catch (error) {
    console.error("Error retrieving user batch:", error.message);
    throw error;
  }
};

// Function to get user by user ID
const getUserByUserId = async (userId) => {
  try {
    const query = "SELECT * FROM users WHERE user_id = $1";
    const res = await pool.query(query, [userId]);
    return res.rows[0];
  } catch (error) {
    console.error("Error retrieving user:", error.message);
    throw error;
  }
};

// Function to insert a new product into the "Product" table

const insertProduct = async (productId, productName, vendorId) => {
  const query = `
    INSERT INTO product (product_id, product_name, v_id)
    VALUES ($1, $2, $3)
    RETURNING *;
  `;
  const values = [productId, productName, vendorId];
  const result = await pool.query(query, values);
  return result.rows[0]; // Returns the newly inserted product, including the p_id
};

const insertMapping = async (featureId, productId, vendorId) => {
  const query = `
    INSERT INTO feature_product_map (f_id, p_id, v_id)
    VALUES ($1, $2, $3);
  `;
  const values = [featureId, productId, vendorId];
  await pool.query(query, values);
};

// Function to delete a product from the "Product" table
const deleteProduct = async (productId) => {
  try {
    // Get `p_id` from `product_id`
    const product = await pool.query(
      `SELECT p_id FROM product WHERE product_id = $1`,
      [productId]
    ); 
    if (product.rows.length === 0) {
      throw new Error("Product not found.");
    }
    const p_id = product.rows[0].p_id;
    // Check if `p_id` is linked in `product_ent_map`
    const linkedEntitlement = await pool.query(
      `SELECT * FROM product_ent_map WHERE p_id = $1`,
      [p_id]
    );
    console.log("Linked Entitlement:", linkedEntitlement.rows); // Debug log
    if (linkedEntitlement.rows.length > 0) {
      throw new Error(
        "Product is linked to an entitlement and cannot be deleted."
      );
    }
    // Proceed with deletion if not linked to any entitlement
    const deleteQuery = `DELETE FROM product WHERE p_id = $1`;
    await pool.query(deleteQuery, [p_id]);
    console.log("Product deleted:", p_id);
  } catch (error) {
    console.error("Error deleting product:", error.message);
    throw error;
  }
};

// Function to retrieve all products from the "Product" table
const getAllProducts = async () => {
  try {
    const productRes = await pool.query("SELECT * FROM product");
    return productRes.rows.map((product) => ({
      p_id: product.p_id,
      productId: product.product_id,
      productName: product.product_name,
      vendorId: product.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving products:", error.message);
    throw error;
  }
};

// Function to retrieve products by vendor
const getProductsByVendor = async (vendorId) => {
  try {
    const query = "SELECT * FROM product WHERE v_id = $1";
    const res = await pool.query(query, [vendorId]);
    return res.rows.map((product) => ({
      p_id: product.p_id,
      productId: product.product_id,
      productName: product.product_name,
      vendorId: product.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving vendor products:", error.message);
    throw error;
  }
};

// Function to insert a new batch with v_id
const insertBatch = async (batchCode, batchName, vendorId) => {
  try {
    // Validate the batchCode to ensure it is within the allowed range
    if (batchCode < 1000000 || batchCode > 9999999) {
      throw new Error("Batch Code must be between 1,000,000 and 9,999,999");
    }

    // Validate vendorId and ensure it's provided
    if (!vendorId) {
      throw new Error("Vendor ID is required");
    }

    // Insert batch with batch_code, batch_name, and v_id
    const query = `
      INSERT INTO batch (batch_code, batch_name, v_id) 
      VALUES ($1, $2, $3)
    `;

    await pool.query(query, [batchCode, batchName, vendorId]);
    console.log(
      "Batch inserted with code:",
      batchCode,
      "name:",
      batchName,
      "vendor ID:",
      vendorId
    );
  } catch (error) {
    console.error("Error inserting batch:", error.message);
    throw error;
  }
};

// Function to retrieve all batches
const getAllBatches = async () => {
  try {
    const res = await pool.query("SELECT * FROM batch");
    return res.rows.map((batch) => ({
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving batches:", error.message);
    throw error;
  }
};
// Function to retrieve a batch by ID
const getBatchById = async (batchId) => {
  try {
    const query = `SELECT * FROM batch WHERE b_id = $1`;
    const res = await pool.query(query, [batchId]);

    if (!res.rows.length) {
      throw new Error(`Batch with ID ${batchId} not found`);
    }

    const batch = res.rows[0];
    return {
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    };
  } catch (error) {
    console.error("Error retrieving batch:", error.message);
    throw error;
  }
};

const getAllBatchesByVendor = async (vendorId) => {
  try {
    const query = `SELECT * FROM batch WHERE v_id = $1`;
    const res = await pool.query(query, [vendorId]);
    return res.rows.map((batch) => ({
      batchId: batch.b_id,
      batchCode: batch.batch_code,
      batchName: batch.batch_name,
      vendorId: batch.v_id,
    }));
  } catch (error) {
    console.error("Error retrieving vendor-specific batches:", error.message);
    throw error;
  }
};

const insertFeatureProductMapping = async (f_id, p_id) => {
  try {
    const query = `INSERT INTO feature_product_map (f_id, p_id) VALUES ($1, $2)`;
    await pool.query(query, [f_id, p_id]);
    console.log("Feature-Product mapping added:", f_id, p_id);
  } catch (error) {
    console.error("Error inserting feature-product mapping:", error.message);
    throw error;
  }
};
const getFeaturesByProductId = async (productId) => {
  try {
    const query = `
      SELECT f.*
      FROM feature f
      JOIN feature_product_map fpm ON f.f_id = fpm.f_id
      JOIN product p ON p.p_id = fpm.p_id
      WHERE p.product_id = $1
    `;
    const res = await pool.query(query, [productId]);
    return res.rows;
  } catch (error) {
    console.error("Error retrieving features by product ID:", error.message);
    throw error;
  }
};
//----------------------------------------Mapping Feature Product-------------------------------------------------//
const getProductsWithFeaturesByVendor = async (vendorId) => {
  try {
    const query = `
  SELECT 
  p.product_id, 
  p.product_name, 
  f.feature_name
  FROM 
  product p
  JOIN 
  feature_product_map m ON p.p_id = m.p_id
  JOIN 
  feature f ON m.f_id = f.f_id
  WHERE 
  p.v_id = $1;
  `;
    const result = await pool.query(query, [vendorId]);
    return result.rows.map((row) => ({
      productId: row.product_id,
      productName: row.product_name,
      featureName: row.feature_name,
    }));
  } catch (error) {
    console.error("Error retrieving products with features:", error.message);
    throw error;
  }
};

// Function to delete product and its related features
const deleteProductAndFeaturesByVendor = async (productId, vendorId) => {
  const client = await pool.connect();
  try {
    await client.query("BEGIN"); // Start transaction

    // Delete from feature_product_map
    const deleteFeatureMapQuery = `
      DELETE FROM feature_product_map
      WHERE p_id = $1
    `;
    await client.query(deleteFeatureMapQuery, [productId]);

    // Delete from product
    const deleteProductQuery = `
      DELETE FROM product
      WHERE p_id = $1 AND v_id = $2
    `;
    await client.query(deleteProductQuery, [productId, vendorId]);

    await client.query("COMMIT"); // Commit transaction
    return { success: true };
  } catch (error) {
    await client.query("ROLLBACK"); // Rollback transaction on error
    console.error("Error deleting product and features:", error.message);
    throw error;
  } finally {
    client.release(); // Release client
  }
};
//-----------------------entitlement and mapping-------------------------------------------//

// ** Database Functions **

// Function to insert a new entitlement
const insertEntitlement = async (entitlementId, date, vendorId) => {
  const query = `
    INSERT INTO entitlement (entitlement_id, date_created, v_id)
    VALUES ($1, $2, $3)
    RETURNING *;
  `;
  const values = [entitlementId, date, vendorId];
  const result = await pool.query(query, values);
  return result.rows[0]; // Returns the newly inserted entitlement, including the e_id
};

const deleteEntitlement = async (entitlementId) => {
  try {
    console.log("Deleting entitlement:", entitlementId);
    const deleteQuery = `DELETE FROM entitlement WHERE e_id = $1`;
    await pool.query(deleteQuery, [entitlementId]);
    console.log("Entitlement deleted:", entitlementId);
  } catch (error) {
    console.error("Error deleting entitlement:", error.message);
    throw error;
  }
};
// Function to insert a product-entitlement mapping
const insertProductEntitlementMapping = async (
  entitlementId,
  productId,
  vendorId
) => {
  const query = `
    INSERT INTO product_ent_map (e_id, p_id, v_id)
    VALUES ($1, $2, $3);
  `;
  const values = [entitlementId, productId, vendorId];
  await pool.query(query, values);
};

const getEntitlementsByVendor = async (vendorId) => {
  try {
    const query = `
  SELECT 
  e.entitlement_id, 
  p.product_name,
  e.date_created
  FROM 
  entitlement e
  JOIN 
  product_ent_map pem ON e.e_id = pem.e_id
  JOIN 
  product p ON pem.p_id = p.p_id
  WHERE 
  e.v_id = $1
  `;
    const result = await pool.query(query, [vendorId]);
    return result.rows.map((row) => ({
      entitlementId: row.entitlement_id,
      productName: row.product_name,
      date: row.date_created, // Include date in the returned object
    }));
  } catch (error) {
    console.error(
      "Error retrieving entitlements with products:",
      error.message
    );
    throw error;
  }
};

// Function to insert data into the feat_prod_ent_map table
const insertIntoFeatProdEntMap = async (data) => {
  try {
    const {
      f_id,
      p_id,
      e_id,
      v_id,
      feature_enable,
      Businesss_model,
      start_date,
      issued_count,
      consumed_count,
      available_count,
      end_date,
      no_of_days,
    } = data;

    const insertQuery = `
      INSERT INTO feat_prod_ent_map (f_id, p_id, e_id, v_id, feature_enable, Businesss_model, start_date, issued_count, consumed_count, available_count, end_date, no_of_days)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING map_id;  -- Return the generated map_id
    `;

    const values = [
      f_id,
      p_id,
      e_id,
      v_id,
      feature_enable,
      Businesss_model,
      start_date,
      issued_count,
      consumed_count,
      available_count,
      end_date,
      no_of_days,
    ];

    const result = await pool.query(insertQuery, values);
    return result.rows[0].map_id; // Return the map_id of the inserted row
  } catch (error) {
    console.error("Error inserting into feat_prod_ent_map:", error);
    throw error; // Re-throw the error to be handled by the calling function
  }
};
// Export all functions for use in other files
module.exports = {
  pool,
  insertFeature,
  deleteFeature,
  getAllFeatureDetailsFromDb,
  getFeaturesByVendor,
  insertUserWithoutPassword,
  insertProduct,
  deleteProduct,
  getAllProducts,
  getUserByUserId,
  insertUser,
  insertUserBatch,
  getProductsByVendor,
  insertBatch,
  getAllBatches,
  getBatchById,
  getAllBatchesByVendor,
  getUserBatch,
  insertFeatureProductMapping,
  getFeaturesByProductId,
  insertMapping,
  getProductsWithFeaturesByVendor,
  insertEntitlement,
  insertProductEntitlementMapping,
  getEntitlementsByVendor,
  deleteProductAndFeaturesByVendor,
  deleteEntitlement,
};


-----------------------------------------------------------------------------
import React, { useState, useEffect } from "react";
import axios from "axios";
import DeleteIcon from "@mui/icons-material/Delete";
import IconButton from "@mui/material/IconButton";
import { ToastContainer, toast } from "react-toastify";
import {
  Box,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Button,
  Modal,
  ToggleButton,
  ToggleButtonGroup,
  Typography,
  TextField,
  Card,
  CardContent,
  CardActions,
  CircularProgress,
  Alert,
} from "@mui/material";
import { Formik, Form } from "formik";
import * as Yup from "yup";

// Generate unique ID for entitlement
const generateUniqueId = () =>
  Math.random().toString(36).substring(2, 10).toUpperCase();

const EntitlementPage = () => {
  const [entitlements, setEntitlements] = useState([]);
  const [selectedEntitlement, setSelectedEntitlement] = useState(null);
  const [openModal, setOpenModal] = useState(false);
  const [products, setProducts] = useState([]);
  const [loadingProducts, setLoadingProducts] = useState(true);
  const [loadingEntitlements, setLoadingEntitlements] = useState(true);
  const [error, setError] = useState("");
  const token = localStorage.getItem("token");
  const vendorId = localStorage.getItem("vendorId"); // Get vendorId from localStorage

  // Fetch products filtered by vendor ID
  useEffect(() => {
    const fetchProducts = async () => {
      setLoadingProducts(true);
      setError("");
      try {
        const token = localStorage.getItem("token");
        if (!token) {
          setError("No token found. Please log in again.");
          return;
        }

        const response = await axios.get("http://localhost:5001/api/products", {
          headers: { Authorization: `Bearer ${token}` },
        });

        setProducts(response.data.products || []);
      } catch (err) {
        setError("Failed to fetch products. Please try again later.");
        console.error("Error fetching products:", err);
      } finally {
        setLoadingProducts(false);
      }
    };
    fetchProducts();
  }, []);

  // Fetch the entitlements with product names
  useEffect(() => {
    const fetchEntitlements = async () => {
      setLoadingEntitlements(true);
      setError("");
      try {
        const token = localStorage.getItem("token");
        if (!token) {
          setError("No token found. Please log in again.");
          return;
        }

        const response = await axios.get(
          "http://localhost:5001/api/entitlements-with-products",
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        setEntitlements(response.data.entitlements || []);
      } catch (err) {
        setError(
          "Failed to fetch entitlements with products. Please try again later."
        );
        console.error("Error fetching entitlements:", err);
      } finally {
        setLoadingEntitlements(false);
      }
    };

    fetchEntitlements();
  }, []);

  // Group the entitlements by entitlementId
  const groupEntitlements = (data) => {
    return data.reduce((acc, current) => {
      if (acc[current.entitlementId]) {
        acc[current.entitlementId].push(current.productName);
      } else {
        acc[current.entitlementId] = [current.productName];
      }
      return acc;
    }, {});
  };

  const validationSchema = Yup.object({
    entitlementId: Yup.string().required("Entitlement ID is required"),
    selectedProducts: Yup.array()
      .min(1, "At least one product must be selected")
      .required("Products are required"),
  });

  const handleSelectEntitlement = (entitlementId) => {
    const selected = entitlements.find(
      (ent) => ent.entitlement_id === entitlementId
    ); // Find the full entitlement object
    setSelectedEntitlement(selected || null); // Handle the case where the entitlement isn't found
  };

  const handleAddEntitlement = async (values, actions) => {
    try {
      const selectedProducts = products.filter((product) =>
        values.selectedProducts.includes(product.productId)
      );

      const productIds = selectedProducts.map((product) => product.p_id);
      const userId = localStorage.getItem("userId"); // Assumes user ID is stored in localStorage

      // Set current date as a fallback
      const currentDate = new Date().toISOString();

      const response = await axios.post(
        "http://localhost:5001/api/entitlements",
        {
          entitlementId: values.entitlementId,
          dates: [currentDate], // Ensure that a date is sent here
          selectedProducts: productIds,
          // vendorId: userId,
        },
        {
          headers: { Authorization: `Bearer ${localStorage.getItem("token")}` },
        }
      );

      // On success, fetch entitlements again
      fetchEntitlements();

      // Close modal and reset form
      setOpenModal(false);
      actions.resetForm();
      setError(""); // Clear any errors on success
    } catch (err) {
      setError("Failed to create entitlement. Please try again.");
      console.error("Error creating entitlement:", err);
    }
  };

  // Fetch entitlements after adding a new one
  const fetchEntitlements = async () => {
    setLoadingEntitlements(true);
    setError("");
    try {
      const token = localStorage.getItem("token");
      if (!token) {
        setError("No token found. Please log in again.");
        return;
      }

      const response = await axios.get(
        "http://localhost:5001/api/entitlements-with-products",
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );

      setEntitlements(response.data.entitlements || []);
    } catch (err) {
      setError(
        "Failed to fetch entitlements with products. Please try again later."
      );
      console.error("Error fetching entitlements:", err);
    } finally {
      setLoadingEntitlements(false);
    }
  };

  const handleDeleteEntitlement = async (entitlementId) => {
    try {
      const response = await axios.delete(
        `${API_BASE_URL}/entitlements/${entitlementId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );

      if (response.status === 200) {
        console.log("Entitlement deleted:", entitlementId);
        await fetchEntitlements(); // Refresh entitlement list
        toast.success("Entitlement deleted successfully.");
      }
    } catch (error) {
      const errorMessage =
        error.response?.data?.message || "Error deleting entitlement.";
      console.error("Delete Error:", errorMessage); // Log error
      toast.error(errorMessage);
    }
  };
  // Grouped entitlements data
  const groupedEntitlements = groupEntitlements(entitlements);

  return (
    <div
      style={{
        flex: 1,
        marginTop: -50,
        paddingTop: 50,
        backgroundColor: "rgba(10, 25, 50, 0.9)", // Dark blue background with opacity
        backdropFilter: "blur(8px)",
        minHeight: 700,
      }}
    >
      <Box className="container" sx={{ display: "flex", gap: 2 }}>
        {/* Card for Entitlement Table */}
        <Card
          className="card"
          sx={{ flex: 1 }}
          style={{
            backgroundColor: "rgba(10, 25, 50, 0.9)", // Dark blue background with opacity
            backdropFilter: "blur(8px)",
            color: "white",
          }}
        >
          <CardContent style={{ color: "white" }}>
            <Typography variant="h6">Entitlements</Typography>
            {loadingEntitlements ? (
              <CircularProgress />
            ) : error ? (
              <Alert severity="error">{error}</Alert>
            ) : (
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell style={{ color: "white" }}>
                      Entitlement ID
                    </TableCell>
                    <TableCell style={{ color: "white" }}>Date</TableCell>{" "}
                    {/* Move Date column here */}
                    <TableCell style={{ color: "white" }}>
                      Products
                    </TableCell>{" "}
                    <TableCell width={7}></TableCell>
                    {/* Move Products column here */}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {Object.keys(groupedEntitlements).length > 0 ? (
                    Object.keys(groupedEntitlements).map((entitlementId) => {
                      const entitlement = entitlements.find(
                        (ent) => ent.entitlementId === entitlementId
                      );
                      return (
                        <TableRow
                          key={entitlementId}
                          hover
                          onClick={() => handleSelectEntitlement(entitlementId)}
                          sx={{ cursor: "pointer" }}
                        >
                          <TableCell style={{ color: "white" }}>
                            {entitlementId}
                          </TableCell>
                          <TableCell style={{ color: "white" }}>
                            {entitlement.date}
                          </TableCell>{" "}
                          <TableCell style={{ color: "white" }}>
                            {groupedEntitlements[entitlementId].join(", ")}
                          </TableCell>{" "}
                          <TableCell>
                            <IconButton
                              style={{ color: "white" }}
                              onClick={() =>
                                handleDeleteEntitlement(
                                  entitlement.entitlementId
                                )
                              }
                            >
                              <DeleteIcon />
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      );
                    })
                  ) : (
                    <TableRow>
                      <TableCell colSpan={3} align="center">
                        No entitlements found.
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            )}
          </CardContent>
          <CardActions>
            <Button
              variant="contained"
              color="primary"
              onClick={() => setOpenModal(true)}
            >
              Create Entitlement
            </Button>
          </CardActions>
        </Card>

        {/* New Card for Selected Entitlement Details */}
        <Card
          className="card"
          sx={{ flex: 1 }}
          style={{
            backgroundColor: "rgba(10, 25, 50, 0.9)", // Dark blue background with opacity
            backdropFilter: "blur(8px)",
            color: "white",
          }}
        >
          <CardContent>
            {selectedEntitlement ? (
              <>
                <Typography variant="h6">Entitlement Details</Typography>
                <Typography variant="subtitle1">
                  ID: {selectedEntitlement.entitlementId}
                </Typography>
                <Typography variant="subtitle1">Products:</Typography>
                {selectedEntitlement.products.map((product) => (
                  <Typography key={product.productId}>
                    - {product.productName}
                  </Typography>
                ))}
              </>
            ) : (
              <Typography variant="h6">
                Select an entitlement to view details
              </Typography>
            )}
          </CardContent>
        </Card>

        {/* Modal for Creating Entitlement */}
        <Modal open={openModal} onClose={() => setOpenModal(false)}>
          <Box
            sx={{
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              padding: 4,
              backgroundColor: "white",
              maxWidth: 600,
              borderRadius: 1,
            }}
          >
            <Formik
              initialValues={{
                entitlementId: generateUniqueId(),
                selectedProducts: [],
              }}
              validationSchema={validationSchema}
              onSubmit={handleAddEntitlement}
            >
              {({ values, setFieldValue, touched, errors }) => (
                <Form>
                  <Typography variant="h6">Add Entitlement</Typography>

                  <TextField
                    label="Entitlement ID"
                    name="entitlementId"
                    value={values.entitlementId}
                    disabled
                    fullWidth
                    margin="normal"
                  />

                  <Typography variant="subtitle1" sx={{ marginBottom: 2 }}>
                    Select Products
                  </Typography>

                  {loadingProducts ? (
                    <CircularProgress />
                  ) : error ? (
                    <Alert severity="error">{error}</Alert>
                  ) : (
                    <ToggleButtonGroup
                      value={values.selectedProducts}
                      onChange={(_event, newSelectedProducts) =>
                        setFieldValue("selectedProducts", newSelectedProducts)
                      }
                      aria-label="Select Products"
                      name="selectedProducts"
                      sx={{
                        marginBottom: 2,
                        display: "flex",
                        flexWrap: "wrap",
                      }}
                    >
                      {products.length > 0 ? (
                        products.map((product) => (
                          <ToggleButton
                            key={product.productId}
                            value={product.productId}
                            aria-label={`Product ${product.productName}`}
                          >
                            {product.productName}
                          </ToggleButton>
                        ))
                      ) : (
                        <Typography>No products available</Typography>
                      )}
                    </ToggleButtonGroup>
                  )}

                  {touched.selectedProducts && errors.selectedProducts && (
                    <Typography
                      variant="body2"
                      color="error"
                      sx={{ marginBottom: 2 }}
                    >
                      {errors.selectedProducts}
                    </Typography>
                  )}

                  <Button variant="contained" color="primary" type="submit">
                    Add Entitlement
                  </Button>
                </Form>
              )}
            </Formik>
          </Box>
        </Modal>
      </Box>
    </div>
  );
};

export default EntitlementPage;
